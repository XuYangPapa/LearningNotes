# 二分查找(Binary Search)

---

## 一、各类场景

**二分查找**顾名思义就是将待搜索区间一分为二后在其中一半里面继续搜素，比如常见的**快速排序**就是利用了二分查找的思想。通常来讲，二分查找是在**有序**集合中查找给定元素在集合中的位置，常见变形有：**有序数组是否包含某元素、元素所在位置、元素不存在时应该被插入的位置、第一个大于某元素的位置、最后一个比某元素小的位置、元素第一次出现的位置、元素最后一次出现的位置**等等。

---

## 二、痛点

二分查找的思想极为简单且容易理解，但是在面对具体问题，需要给出具体代码时，往往无法给出清晰完备的代码，需要不断debug。尤其是在以下几个位置通常拿捏不准：

* 中位数向上取整还是向下取整？
* 退出循环的条件是`low > high`还是`low == high`还是`low >= high`？
* 各种边界条件如何表示？
* 什么时候`+1`什么时候`-1`什么时候不变？
* 最后返回`low`还是返回`high`？

没有完全理解二分查找的细节就去写二分查找算法很容易在上述几个问题间反复纠结，通常我们会根据自己的经验去对上述几个问题进行判断，“上次我好像是这么写的对的”、“上次返`low`好像有问题，应该返回`high`”，结果就是反复的debug，耗去很长时间。

---

## 三、解决方案

### 3.1 核心概念

二分查找存在上述那么多可左可右的问题，究其根本是因为二分查找存在很多种写法。二分查找的思想是根据**中间点**不断二分当前的**搜索空间**来寻找**目标位置**，直至**退出**。这里面包含了四个核心概念：**目标位置、中点、搜索空间和退出条件**。

#### 3.1.1 目标位置

二分查找的目标可以被分为以下四种类型：

![preview](https://xuyang-markdown.oss-cn-beijing.aliyuncs.com/img/v2-3ad905d1a5276313416194e75427e368_r-20211125134451950.jpg)

通常我们更为关注下方的两种，因为找到对应的**下界**以后我们可以通过下标`-1`得到相应互补的**上界**，下面我们主要针对`>=value`的下界和`<=value`的上界进行讨论。

#### 3.1.2 中点

在一个数组里，中位数是分为**下中位数 **和**上中位数**：（下述`/`均为整除）

* **下中位数: `lowerMid = low + (high - low) / 2` **
* **上中位数: `upperMid = high - (high - low) / 2`**

注意在计算中点时不要图方便写成`mid = (low + high) / 2`，这种写法在Java和c++中是可能存在int整型溢出的。

通常来说，我们会选取下中位数作为中点，因为二分查找寻找下界的情况更多一些。

#### 3.1.3 搜素空间

二分查找的搜索空间由搜索下界`low`和搜索上界`high`决定，区间开闭造成了各种边界条件混乱不清。搜索空间一共可以有四种选择：**前开后闭`( ]`、前闭后开`[ )`、前闭后闭`[ ]`、前开后开`( )`**，四种搜索空间定义对应了不同的二分查找写法。

通常来说，我们会选择前闭后开`[ )`或前闭后闭`[ ]`来定义我们的搜索空间。选择前闭后开`[ )`的理由是：这种写法更符合我们编程的习惯（比如写一个n次的循环，结束条件一般都是 `i < n`，再比如pthon中的range、slice、切片，java中的substring等等对区间的定义都是前闭后开），且区间两端值的差正好是区间的长度；选择前闭后闭`[ ]`的理由是：不需要区分对待空间的上界和下界，避免空间上界超出索引或者没被处理到的情况。

#### 3.1.4 退出条件

二分查找退出搜索的关键在于搜索空间为空，退出条件分为两种：

* `low >= high`：选择前闭后开`[ )`区间，当`low >= high`时即可退出循环（`[low, high)`在`low = high`时为空）
* `low > high`：选择前闭后闭`[ ]`区间，当`low > high`时即可退出循环（`[low, high]`在`low > high`时为空）

### 3.2 代码

**1. 基础版**

```python
def bi_search_basic(nums, target):
    """
    无重复、升序列表
    存在时返回target所在位置，不存在时返回元素应该被插入位置（或-1）
    """
    low, high = 0, len(nums) - 1  # 双闭区间
    while low <= high:  # 双闭区间的退出条件
        mid = low + (high - low) // 2  # 下中位数
        if nums[mid] == target:
            return mid
        elif nums[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return low  # 也可为-1

```

**2. 查找`>=value`的下界（前闭后闭写法）**

```python
def bi_search_findLower_closeInterval(nums, target):
    """
    有重复、升序列表（适用于无重复的情况）
    存在时返回target所在位置，不存在时返回元素应该被插入位置
    搜索空间采用双闭
    """
    low, high = 0, len(nums) - 1  # 双闭区间
    while low <= high:  # 双闭区间退出条件
        mid = low + (high - low) // 2  # 下中位数
        if nums[mid] == target:
            high = mid - 1
        elif nums[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return low
```

**3. 查找`>=value`的下界（前闭后开写法）**

```python
def bi_search_findLower_openInterval(nums, target):
    """
    有重复、升序列表（适用于无重复的情况）
    存在时返回target所在位置，不存在时返回元素应该被插入位置
    搜索空间采用前闭后开
    """
    low, high = 0, len(nums)    # 前闭后开区间
    while low < high:   # 前闭后开区间的退出条件
        mid = low + (high - low) // 2   # 下中位数
        if nums[mid] == target:
            high = mid
        elif nums[mid] > target:
            high = mid
        else:
            low = mid + 1
    return low
```

---

## 四、其他

查找`>=value`的下界可以兼容无重复升序列表中查找目标元素具体位置；

若需查找`<=value`的上界可以在2和3写法的基础上，取上中位数，然后从右向左压缩搜索空间；













